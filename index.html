<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Esploratore del Sistema Solare (3D)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #hud {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      color: #eaeaea; background: rgba(10,10,12,.72); border: 1px solid rgba(255,255,255,.12);
      padding: 12px 12px; border-radius: 14px; backdrop-filter: blur(10px);
      width: min(430px, calc(100vw - 24px));
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    #hud h1 { margin: 0 0 8px; font-size: 14px; letter-spacing:.2px; opacity:.95; }
    #hud .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 8px 0; }
    #hud label { font-size: 12px; opacity:.9; display:flex; gap:6px; align-items:center; }
    #hud select, #hud input[type="range"], #hud button {
      background: rgba(255,255,255,.06);
      color: #eee;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }
    #hud input[type="range"] { padding: 0; height: 18px; }
    #hud button { cursor:pointer; }
    #hud button:hover { background: rgba(255,255,255,.10); }
    #help {
      margin-top: 8px;
      font-size: 12px;
      line-height: 1.35;
      opacity:.92;
    }
    #help details summary { cursor:pointer; }
    #readout {
      margin-top: 10px;
      font-size: 12px;
      line-height: 1.35;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
    }
    .tag {
      display:inline-block; padding:2px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-size: 11px; margin-right: 6px;
    }

    /* Etichette corpi celesti */
    .label {
      position: fixed; z-index: 9;
      transform: translate(-50%, -50%);
      pointer-events: none;
      font-size: 12px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 2px 8px rgba(0,0,0,.85);
      padding: 3px 6px;
      border-radius: 8px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      white-space: nowrap;
    }

    #footerTip {
      position: fixed; bottom: 10px; left: 12px; z-index: 10;
      color: rgba(255,255,255,.82);
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(10,10,12,.55);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(8px);
      max-width: min(520px, calc(100vw - 24px));
    }
    #footerTip kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color: #f1f1f1;
    }
  </style>
</head>

<body>
  <div id="hud">
    <h1>üåç Esploratore del Sistema Solare ‚Äî prototipo 3D</h1>

    <div class="row">
      <label>üéØ Focus
        <select id="focusSelect">
          <option value="sun">Sole</option>
          <option value="earth" selected>Terra</option>
          <option value="moon">Luna</option>
          <option value="mars">Marte</option>
        </select>
      </label>

      <button id="resetBtn" title="Ripristina camera e tempo">Reset</button>

      <label><input id="pauseChk" type="checkbox"> Pausa</label>
    </div>

    <div class="row">
      <label>‚è±Ô∏è Velocit√† tempo
        <input id="timeRange" type="range" min="0" max="200" value="35">
      </label>
      <span class="tag" id="timeTag">x35</span>
    </div>

    <div class="row">
      <label><input id="distRealChk" type="checkbox"> Distanze realistiche</label>
      <label><input id="sizeRealChk" type="checkbox"> Dimensioni realistiche</label>
      <label><input id="vectorsChk" type="checkbox" checked> Vettori orbitali</label>
      <label><input id="orbitsChk" type="checkbox" checked> Tracce orbite</label>
    </div>

    <div class="row">
      <label>üìè Misura distanza
        <select id="fromSelect">
          <option value="earth" selected>Terra</option>
          <option value="moon">Luna</option>
          <option value="mars">Marte</option>
          <option value="sun">Sole</option>
        </select>
      </label>
      <label>‚Üí
        <select id="toSelect">
          <option value="moon" selected>Luna</option>
          <option value="earth">Terra</option>
          <option value="mars">Marte</option>
          <option value="sun">Sole</option>
        </select>
      </label>
    </div>

    <div id="readout">
      <div><span class="tag">Didattica</span> Orbite (qui semplificate circolari) + confronto distanze/scale</div>
      <div id="measureLine">Caricamento‚Ä¶</div>
      <div id="extraFacts" style="margin-top:8px; opacity:.95;"></div>
    </div>

    <div id="help">
      <details>
        <summary>Controlli (clicca)</summary>
        <ul style="margin:8px 0 0 18px; padding:0;">
          <li>Mouse trascina: ruota attorno al target</li>
          <li>Rotella: zoom</li>
          <li>Tasto destro trascina: pan</li>
          <li><b>1</b> Sole, <b>2</b> Terra, <b>3</b> Luna, <b>4</b> Marte</li>
          <li><b>Space</b> pausa / riprendi</li>
        </ul>
      </details>
    </div>
  </div>

  <div id="footerTip">
    Suggerimento: attiva <kbd>Distanze realistiche</kbd> per capire quanto la Luna ‚Äú√® lontana‚Äù rispetto alla Terra, e <kbd>Dimensioni realistiche</kbd> per vedere quanto i pianeti diventano piccoli a scala vera.
  </div>

  <div id="labels"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // -----------------------------
    // Dati reali (km, giorni)
    // -----------------------------
    const KM = 1;
    const AU_KM = 149_597_870 * KM;

    const bodiesData = {
      sun:   { name: "Sole",  radiusKm: 696_340,  color: 0xffcc55 },
      earth: { name: "Terra", radiusKm: 6_371,    color: 0x3d7cff, orbitKm: AU_KM,        periodDays: 365.256 },
      moon:  { name: "Luna",  radiusKm: 1_737.4,  color: 0xd9d9d9, orbitKm: 384_400,      periodDays: 27.3217, parent: "earth" },
      mars:  { name: "Marte", radiusKm: 3_389.5,  color: 0xff6a3d, orbitKm: 1.523679*AU_KM, periodDays: 686.971 }
    };

    // Scala di default (comoda per ‚Äúgiocare‚Äù)
    // 1 unit√† = 1.000.000 km per le distanze
    const DIST_SCALE_DEFAULT = 1_000_000;
    // dimensioni ‚Äúesagerate‚Äù per vederle bene
    const SIZE_SCALE_DEFAULT = 2200;

    let distReal = false;
    let sizeReal = false;

    function distScale() { return distReal ? DIST_SCALE_DEFAULT : DIST_SCALE_DEFAULT; }
    function sizeScale() { return sizeReal ? 1 : SIZE_SCALE_DEFAULT; }

    // -----------------------------
    // Setup scena
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 5000);
    camera.position.set(0, 80, 180);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 1;
    controls.maxDistance = 2000;

    // Luci: ‚Äúsole‚Äù come sorgente forte + ambient soft
    const ambient = new THREE.AmbientLight(0xffffff, 0.10);
    scene.add(ambient);

    const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 2);
    sunLight.position.set(0,0,0);
    scene.add(sunLight);

    // ‚ÄúStelle‚Äù (semplice, leggero)
    const starsGeo = new THREE.BufferGeometry();
    const starCount = 2500;
    const starPos = new Float32Array(starCount * 3);
    for (let i=0; i<starCount; i++){
      const r = 1800 * Math.cbrt(Math.random());
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2*Math.random()-1);
      starPos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
      starPos[i*3+1] = r * Math.cos(phi);
      starPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
    }
    starsGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: 1.2, sizeAttenuation: true, color: 0xffffff }));
    scene.add(stars);

    // -----------------------------
    // Creazione corpi
    // -----------------------------
    const bodies = {}; // mesh
    const pivots = {}; // pivot per orbite
    const labels = {};

    const labelsRoot = document.getElementById("labels");

    function makeLabel(key, text) {
      const div = document.createElement("div");
      div.className = "label";
      div.textContent = text;
      labelsRoot.appendChild(div);
      labels[key] = div;
    }

    function makePlanetMaterial(baseColor, glossy=false){
      // Materiale semplice ma ‚Äúcredibile‚Äù (specular per Terra)
      return new THREE.MeshStandardMaterial({
        color: baseColor,
        roughness: glossy ? 0.55 : 0.9,
        metalness: 0.0
      });
    }

    function makeAtmosphere(radius){
      const geo = new THREE.SphereGeometry(radius * 1.03, 64, 64);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x66aaff,
        transparent: true,
        opacity: 0.12,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide
      });
      const mesh = new THREE.Mesh(geo, mat);
      return mesh;
    }

    function makeBody(key){
      const d = bodiesData[key];
      const radiusUnits = (d.radiusKm / distScale()) * sizeScale(); // radius in scene units
      const geo = new THREE.SphereGeometry(Math.max(radiusUnits, 0.15), 64, 64);

      let mat;
      if (key === "sun"){
        mat = new THREE.MeshBasicMaterial({ color: d.color });
      } else if (key === "earth"){
        mat = makePlanetMaterial(d.color, true);
      } else {
        mat = makePlanetMaterial(d.color, false);
      }

      const mesh = new THREE.Mesh(geo, mat);
      mesh.name = key;
      mesh.userData.radiusUnits = radiusUnits;

      // Piccolo ‚Äúglow‚Äù sul Sole
      if (key === "sun"){
        const glowGeo = new THREE.SphereGeometry(Math.max(radiusUnits, 1.0) * 1.08, 64, 64);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, transparent: true, opacity: 0.25 });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        mesh.add(glow);
      }

      // Atmosfera sulla Terra
      if (key === "earth"){
        mesh.add(makeAtmosphere(Math.max(radiusUnits, 0.15)));
        // ‚ÄúNuvole‚Äù (layer leggero)
        const cloudGeo = new THREE.SphereGeometry(Math.max(radiusUnits, 0.15) * 1.01, 64, 64);
        const cloudMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.10,
          roughness: 1.0,
          metalness: 0.0
        });
        const clouds = new THREE.Mesh(cloudGeo, cloudMat);
        clouds.userData.isClouds = true;
        mesh.add(clouds);
      }

      return mesh;
    }

    // Pivots orbite
    function makeOrbitPivot(key){
      const pivot = new THREE.Object3D();
      pivot.name = key + "_pivot";
      return pivot;
    }

    // Orbits lines (circolari)
    const orbitLines = {};

    function makeOrbitLine(radiusUnits, color=0x334455){
      const segments = 256;
      const pts = [];
      for (let i=0; i<=segments; i++){
        const a = (i/segments) * Math.PI * 2;
        pts.push(new THREE.Vector3(Math.cos(a)*radiusUnits, 0, Math.sin(a)*radiusUnits));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity: 0.6 });
      return new THREE.Line(geo, mat);
    }

    // Crea Sole
    bodies.sun = makeBody("sun");
    scene.add(bodies.sun);
    makeLabel("sun", "Sole");

    // Crea Terra e Marte con pivot intorno al Sole
    ["earth","mars"].forEach(key => {
      const p = makeOrbitPivot(key);
      pivots[key] = p;
      scene.add(p);

      bodies[key] = makeBody(key);
      p.add(bodies[key]);

      // posizionamento iniziale
      const rUnits = (bodiesData[key].orbitKm / distScale());
      bodies[key].position.set(rUnits, 0, 0);

      makeLabel(key, bodiesData[key].name);

      orbitLines[key] = makeOrbitLine(rUnits, key==="earth" ? 0x2a4d8f : 0x6b2f22);
      scene.add(orbitLines[key]);
    });

    // Luna con pivot attaccato alla Terra
    pivots.moon = makeOrbitPivot("moon");
    bodies.earth.add(pivots.moon);

    bodies.moon = makeBody("moon");
    pivots.moon.add(bodies.moon);

    const moonRUnits = (bodiesData.moon.orbitKm / distScale());
    bodies.moon.position.set(moonRUnits, 0, 0);

    makeLabel("moon", "Luna");
    orbitLines.moon = makeOrbitLine(moonRUnits, 0x777777);
    bodies.earth.add(orbitLines.moon);

    // -----------------------------
    // Vettori (velocit√† tangenziale ‚Äúdidattica‚Äù)
    // -----------------------------
    const vectorLines = {
      earth: new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(), 12, 0x66ccff),
      mars:  new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(), 10, 0xff8866),
      moon:  new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(), 6,  0xdddddd)
    };
    scene.add(vectorLines.earth);
    scene.add(vectorLines.mars);
    scene.add(vectorLines.moon);

    function updateVectors(){
      // Direzione tangenziale: per orbita nel piano XZ, tangente = rotazione di 90¬∞ del raggio
      const ePos = bodies.earth.getWorldPosition(new THREE.Vector3());
      const mPos = bodies.mars.getWorldPosition(new THREE.Vector3());
      const moonPos = bodies.moon.getWorldPosition(new THREE.Vector3());
      const earthCenter = new THREE.Vector3(0,0,0);
      const marsCenter  = new THREE.Vector3(0,0,0);
      const moonCenter  = bodies.earth.getWorldPosition(new THREE.Vector3());

      function tangentialDir(pos, center){
        const r = pos.clone().sub(center);
        const t = new THREE.Vector3(-r.z, 0, r.x).normalize();
        return t;
      }

      // lunghezze indicative (non fisicamente scalate)
      vectorLines.earth.position.copy(ePos);
      vectorLines.earth.setDirection(tangentialDir(ePos, earthCenter));
      vectorLines.earth.setLength(14, 3, 2);

      vectorLines.mars.position.copy(mPos);
      vectorLines.mars.setDirection(tangentialDir(mPos, marsCenter));
      vectorLines.mars.setLength(12, 3, 2);

      vectorLines.moon.position.copy(moonPos);
      vectorLines.moon.setDirection(tangentialDir(moonPos, moonCenter));
      vectorLines.moon.setLength(7, 2, 1.5);
    }

    // -----------------------------
    // Misuratore distanza (linea + testo)
    // -----------------------------
    let measureFrom = "earth";
    let measureTo = "moon";

    const measureMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
    const measureGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const measureLineObj = new THREE.Line(measureGeo, measureMat);
    scene.add(measureLineObj);

    const measureLineText = document.getElementById("measureLine");
    const extraFacts = document.getElementById("extraFacts");

    function kmDistance(aKey, bKey){
      const a = bodies[aKey].getWorldPosition(new THREE.Vector3());
      const b = bodies[bKey].getWorldPosition(new THREE.Vector3());
      const distUnits = a.distanceTo(b);
      const km = distUnits * distScale(); // perch√© 1 unit = distScale km
      return { km, distUnits };
    }

    function fmtKm(km){
      if (km >= 1e9) return (km/1e9).toFixed(3) + " miliardi km";
      if (km >= 1e6) return (km/1e6).toFixed(3) + " milioni km";
      return Math.round(km).toLocaleString("it-IT") + " km";
    }

    function updateMeasure(){
      const a = bodies[measureFrom].getWorldPosition(new THREE.Vector3());
      const b = bodies[measureTo].getWorldPosition(new THREE.Vector3());
      measureGeo.setFromPoints([a, b]);

      const { km } = kmDistance(measureFrom, measureTo);
      measureLineText.innerHTML =
        `<b>Distanza</b> ${bodiesData[measureFrom].name} ‚Üí ${bodiesData[measureTo].name}: <b>${fmtKm(km)}</b>`;

      // pillole didattiche rapide (meccanica orbitale + scale)
      const earthMoon = kmDistance("earth","moon").km;
      const earthMars = kmDistance("earth","mars").km;

      const earthDiamKm = bodiesData.earth.radiusKm * 2;
      const moonDiamKm  = bodiesData.moon.radiusKm * 2;

      extraFacts.innerHTML = `
        <div>‚Ä¢ La Luna orbita attorno alla Terra: qui la traiettoria √® mostrata come cerchio (nella realt√† √® ellittica e ‚Äúperturbata‚Äù).</div>
        <div>‚Ä¢ Confronto scale: <b>Diametro Terra</b> ‚âà ${fmtKm(earthDiamKm)} ¬∑ <b>Diametro Luna</b> ‚âà ${fmtKm(moonDiamKm)}.</div>
        <div>‚Ä¢ Distanze: <b>Terra‚ÄìLuna</b> ‚âà ${fmtKm(earthMoon)} ¬∑ <b>Terra‚ÄìMarte</b> (qui istantanea) ‚âà ${fmtKm(earthMars)}.</div>
        <div style="margin-top:6px; opacity:.9;">
          Idea chiave: un‚Äôorbita √® un ‚Äúcadere continuamente‚Äù mentre si va abbastanza veloce in direzione tangenziale.
        </div>
      `;
    }

    // -----------------------------
    // UI
    // -----------------------------
    const focusSelect = document.getElementById("focusSelect");
    const resetBtn = document.getElementById("resetBtn");
    const pauseChk = document.getElementById("pauseChk");
    const timeRange = document.getElementById("timeRange");
    const timeTag = document.getElementById("timeTag");
    const distRealChk = document.getElementById("distRealChk");
    const sizeRealChk = document.getElementById("sizeRealChk");
    const vectorsChk = document.getElementById("vectorsChk");
    const orbitsChk = document.getElementById("orbitsChk");
    const fromSelect = document.getElementById("fromSelect");
    const toSelect = document.getElementById("toSelect");

    function focusOn(key){
      const target = bodies[key].getWorldPosition(new THREE.Vector3());
      controls.target.copy(target);

      // Metti la camera a una distanza ‚Äúcomoda‚Äù in base al raggio
      const radius = bodies[key].userData.radiusUnits ?? 5;
      const offset = new THREE.Vector3(1.2, 0.8, 1.4).normalize().multiplyScalar(Math.max(radius*6, 40));
      camera.position.copy(target.clone().add(offset));
      controls.update();
    }

    function rebuildScales(){
      // Ricostruisci geometrie dimensioni in base ai toggle scale
      // (semplice: rimuoviamo e ricreiamo le mesh)
      const oldFocus = focusSelect.value;

      // Salva posizioni angolari correnti dai pivot (rotazioni)
      const earthRot = pivots.earth.rotation.y;
      const marsRot  = pivots.mars.rotation.y;
      const moonRot  = pivots.moon.rotation.y;

      // Rimuovi tutto tranne stelle e luci
      ["sun","earth","mars","moon"].forEach(k => {
        if (labels[k]) labels[k].remove();
      });
      labelsRoot.innerHTML = "";

      Object.values(orbitLines).forEach(l => l.remove());
      Object.keys(orbitLines).forEach(k => delete orbitLines[k]);

      scene.remove(measureLineObj);
      scene.remove(vectorLines.earth); scene.remove(vectorLines.mars); scene.remove(vectorLines.moon);

      // Pulisci pivots e bodies
      Object.values(pivots).forEach(p => p.removeFromParent());
      Object.values(bodies).forEach(m => m.removeFromParent());
      for (const k of Object.keys(pivots)) delete pivots[k];
      for (const k of Object.keys(bodies)) delete bodies[k];

      // Ricrea
      bodies.sun = makeBody("sun");
      scene.add(bodies.sun);
      makeLabel("sun", "Sole");

      ["earth","mars"].forEach(key => {
        const p = makeOrbitPivot(key);
        pivots[key] = p;
        scene.add(p);

        bodies[key] = makeBody(key);
        p.add(bodies[key]);

        const rUnits = (bodiesData[key].orbitKm / distScale());
        bodies[key].position.set(rUnits, 0, 0);

        makeLabel(key, bodiesData[key].name);

        orbitLines[key] = makeOrbitLine(rUnits, key==="earth" ? 0x2a4d8f : 0x6b2f22);
        scene.add(orbitLines[key]);
      });

      pivots.moon = makeOrbitPivot("moon");
      bodies.earth.add(pivots.moon);

      bodies.moon = makeBody("moon");
      pivots.moon.add(bodies.moon);

      const moonRUnits2 = (bodiesData.moon.orbitKm / distScale());
      bodies.moon.position.set(moonRUnits2, 0, 0);

      makeLabel("moon", "Luna");
      orbitLines.moon = makeOrbitLine(moonRUnits2, 0x777777);
      bodies.earth.add(orbitLines.moon);

      // Ripristina rotazioni orbitali
      pivots.earth.rotation.y = earthRot;
      pivots.mars.rotation.y  = marsRot;
      pivots.moon.rotation.y  = moonRot;

      // Re-add misuratore e vettori
      scene.add(measureLineObj);
      scene.add(vectorLines.earth);
      scene.add(vectorLines.mars);
      scene.add(vectorLines.moon);

      // Toggle visibilit√†
      Object.values(orbitLines).forEach(l => l.visible = orbitsChk.checked);
      vectorLines.earth.visible = vectorsChk.checked;
      vectorLines.mars.visible  = vectorsChk.checked;
      vectorLines.moon.visible  = vectorsChk.checked;

      focusOn(oldFocus);
      updateMeasure();
    }

    focusSelect.addEventListener("change", () => focusOn(focusSelect.value));
    resetBtn.addEventListener("click", () => {
      pauseChk.checked = false;
      timeRange.value = 35;
      timeTag.textContent = "x35";
      simTimeDays = 0;
      focusSelect.value = "earth";
      focusOn("earth");
    });

    fromSelect.addEventListener("change", () => { measureFrom = fromSelect.value; updateMeasure(); });
    toSelect.addEventListener("change", () => { measureTo = toSelect.value; updateMeasure(); });

    timeRange.addEventListener("input", () => {
      timeTag.textContent = "x" + timeRange.value;
    });

    distRealChk.addEventListener("change", () => {
      // Nota: in questo prototipo distReal non cambia il DIST_SCALE (rimane coerente),
      // ma il checkbox √® utile per ‚Äúmodalit√† didattica‚Äù: potresti collegarlo a scale pi√π estreme.
      distReal = distRealChk.checked;
      rebuildScales();
    });

    sizeRealChk.addEventListener("change", () => {
      sizeReal = sizeRealChk.checked;
      rebuildScales();
    });

    vectorsChk.addEventListener("change", () => {
      vectorLines.earth.visible = vectorsChk.checked;
      vectorLines.mars.visible  = vectorsChk.checked;
      vectorLines.moon.visible  = vectorsChk.checked;
    });

    orbitsChk.addEventListener("change", () => {
      Object.values(orbitLines).forEach(l => l.visible = orbitsChk.checked);
    });

    // Tasti rapidi
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space"){
        pauseChk.checked = !pauseChk.checked;
      }
      if (e.key === "1"){ focusSelect.value="sun"; focusOn("sun"); }
      if (e.key === "2"){ focusSelect.value="earth"; focusOn("earth"); }
      if (e.key === "3"){ focusSelect.value="moon"; focusOn("moon"); }
      if (e.key === "4"){ focusSelect.value="mars"; focusOn("mars"); }
    });

    // -----------------------------
    // Simulazione: orbite (semplificate)
    // -----------------------------
    let simTimeDays = 0;
    const clock = new THREE.Clock();

    function updateOrbits(dtDays){
      // Angolo = 2œÄ * t / periodo
      // Terra intorno al Sole
      const earthAng = (simTimeDays / bodiesData.earth.periodDays) * Math.PI * 2;
      pivots.earth.rotation.y = earthAng;

      // Marte intorno al Sole
      const marsAng = (simTimeDays / bodiesData.mars.periodDays) * Math.PI * 2;
      pivots.mars.rotation.y = marsAng * 0.98; // piccola differenza per ‚Äúvariare‚Äù la scena

      // Luna intorno alla Terra
      const moonAng = (simTimeDays / bodiesData.moon.periodDays) * Math.PI * 2;
      pivots.moon.rotation.y = moonAng * 1.02;

      // Rotazioni proprie (giorno/notte)
      bodies.earth.rotation.y += dtDays * (Math.PI * 2) * (1/1.0); // ~1 giro al giorno
      bodies.mars.rotation.y  += dtDays * (Math.PI * 2) * (1/1.03);
      // Nuvole terra pi√π lente
      const clouds = bodies.earth.children.find(c => c.userData?.isClouds);
      if (clouds) clouds.rotation.y += dtDays * (Math.PI * 2) * 0.35;
    }

    // -----------------------------
    // Etichette 2D (proiezione)
    // -----------------------------
    const tmpV = new THREE.Vector3();
    function updateLabels(){
      const w = window.innerWidth, h = window.innerHeight;

      for (const key of ["sun","earth","moon","mars"]){
        const div = labels[key];
        if (!div) continue;

        const pos = bodies[key].getWorldPosition(tmpV);
        const projected = pos.clone().project(camera);

        const x = (projected.x * 0.5 + 0.5) * w;
        const y = (-projected.y * 0.5 + 0.5) * h;

        // Nascondi se dietro la camera
        div.style.display = projected.z > 1 ? "none" : "block";
        div.style.left = x + "px";
        div.style.top  = y + "px";
      }
    }

    // -----------------------------
    // Resize
    // -----------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Avvio: focus Terra
    focusOn("earth");
    updateMeasure();

    // -----------------------------
    // Render loop
    // -----------------------------
    function animate(){
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      controls.update();

      if (!pauseChk.checked){
        const speed = Number(timeRange.value); // ‚Äúx‚Äù
        const dtDays = (dt * speed) * 0.2;     // fattore per rendere piacevole la velocit√†
        simTimeDays += dtDays;
        updateOrbits(dtDays);
      }

      updateVectors();
      updateMeasure();
      updateLabels();

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
